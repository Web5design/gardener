var fs, mkdirp, path, EventEmitter, zlib, out$ = typeof exports != 'undefined' && exports || this;
fs = require('fs');
mkdirp = require('mkdirp');
path = require('path');
EventEmitter = require('events').EventEmitter;
zlib = require('zlib');
out$.create = create;
function create(file_path, max_size, cb){
  createStream(file_path, function(err, stream, size){
    var pending, log;
    if (err) {
      return cb(err);
    }
    pending = null;
    log = new EventEmitter();
    stream.on('error', function(error){
      return log.emit('error', error);
    });
    log.write = function(str){
      var flushed, archive_name;
      flushed = stream.write(str);
      size += str.length;
      if (pending === 'flush') {
        if (flushed) {
          pending = null;
        } else {
          stream.once('drain', function(){
            pending = null;
          });
        }
      }
      if (pending == null && size >= max_size) {
        pending = 'rename';
        archive_name = archiveName(file_path);
        fs.rename(file_path, archive_name, function(err){
          if (err) {
            return log.emit('error', err);
          }
          createStream(file_path, function(err, new_stream, new_size){
            if (err) {
              return log.emit('error', err);
            }
            stream.once('close', function(){
              var gzip, inp, out;
              gzip = zlib.createGzip();
              inp = fs.createReadStream(archive_name);
              out = fs.createWriteStream(archive_name + ".gz");
              inp.on('error', function(error){
                return log.emit('error', error);
              });
              out.on('error', function(error){
                return log.emit('error', error);
              });
              inp.pipe(gzip).pipe(out);
              out.once('close', function(){
                fs.unlink(archive_name, function(err){
                  if (err) {
                    return log.emit('error', err);
                  }
                });
              });
            });
            stream.end();
            new_stream.on('error', function(error){
              return log.emit('error', error);
            });
            size = new_size;
            stream = new_stream;
            pending = 'flush';
          });
        });
      }
    };
    cb(null, log);
  });
}
function getFileSize(file_path, cb){
  fs.stat(file_path, function(err, stats){
    if (err) {
      if (err.code === 'ENOENT') {
        return cb(null, 0);
      } else {
        return cb(err);
      }
    } else {
      cb(null, stats.size);
    }
  });
}
function createStream(file_path, cb){
  mkdirp(path.dirname(file_path), function(err){
    if (err) {
      return cb(err);
    }
    getFileSize(file_path, function(err, size){
      var stream;
      if (err) {
        return cb(err);
      }
      stream = fs.createWriteStream(file_path, {
        flags: 'a'
      });
      cb(null, stream, size);
    });
  });
}
function archiveName(file_path){
  var dirname, extname, basename, timestamp;
  dirname = path.dirname(file_path);
  extname = path.extname(file_path);
  basename = path.basename(file_path, extname);
  timestamp = new Date().getTime();
  return path.join(dirname, basename + "-" + timestamp + extname);
}